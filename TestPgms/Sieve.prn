(   1)                  ; ;    1: PROGRAM eratosthenes (output);
(   2)                  ; 	.stk 1024
(   3)                  ; 	.cod 512
(   4)                  ; STATIC_LINK .equ +5
(   5)                  ; RETURN_VALUE .equ -3
(   6)                  ; HIGH_RETURN_VALUE .equ -1
(   7)                  ; _start
(   8) 0200 ABBA        ; 	tsx.w		; Preserve original stack pointer
(   9) 0202 CBA21C11    ; 	lds.w #_stk_top	; Initialize program stack pointer
(  10) 0206 9C4105      ; 	stz _bss_start
(  11) 0209 ABA24105    ; 	ldx.w #_bss_start
(  12) 020D ABA04205    ; 	ldy.w #_bss_start+1
(  13) 0211 ABA91C11    ; 	lda.w #_stk_top
(  14) 0215 38          ; 	sec
(  15) 0216 ABE94105    ; 	sbc.w #_bss_start
(  16) 021A 540A        ; 	mov #10
(  17) 021C 4C1F02      ; 	jmp _pc65_main
(  18)                  ; ;    2: 
(  19)                  ; ;    3: CONST
(  20)                  ; ;    4:     max = 1000;
(  21)                  ; ;    5: 
(  22)                  ; ;    6: VAR
(  23)                  ; ;    7:     sieve : ARRAY [1..max] OF BOOLEAN;
(  24)                  ; ;    8:     i, j, limit, prime, factor : INTEGER;
(  25)                  ; ;    9: 
(  26)                  ; ;   10: BEGIN
(  27)                  ; _pc65_main .sub
(  28) 021F ABDA        ; 	phx.w
(  29) 0221 ABBA        ; 	tsx.w
(  30)                  ; ;   11:     limit := max DIV 2;
(  31) 0223 ABA9E803    ; 	lda.w #1000
(  32) 0227 AB48        ; 	pha.w
(  33) 0229 A902        ; 	lda #2
(  34) 022B AB48        ; 	pha.w
(  35) 022D 203104      ; 	jsr _idiv
(  36) 0230 C204        ; 	adj #4
(  37) 0232 AB8D160D    ; 	sta.w limit_005
(  38)                  ; ;   12:     sieve[1] := FALSE;
(  39) 0236 ABE24205    ; 	psh.w #sieve_002
(  40) 023A A901        ; 	lda #1
(  41) 023C AB3A        ; 	dec.w a
(  42) 023E AB0A        ; 	asl.w a
(  43) 0240 18          ; 	clc
(  44) 0241 CB7501      ; 	adc.w 1,S
(  45) 0244 CB9501      ; 	sta.w 1,S
(  46) 0247 A900        ; 	lda #0
(  47) 0249 8B6B        ; 	pli.s
(  48) 024B AB8300      ; 	sta.w 0,I++
(  49)                  ; ;   13: 
(  50)                  ; ;   14:     FOR i := 2 TO max DO
(  51) 024E A902        ; 	lda #2
(  52) 0250 AB8D120D    ; 	sta.w i_003
(  53)                  ; L_008
(  54) 0254 ABA9E803    ; 	lda.w #1000
(  55) 0258 ABCD120D    ; 	cmp.w i_003
(  56) 025C AB5003      ; 	bge L_009
(  57) 025F 4C8302      ; 	jmp L_010
(  58)                  ; L_009
(  59)                  ; ;   15:         sieve[i] := TRUE;
(  60) 0262 ABE24205    ; 	psh.w #sieve_002
(  61) 0266 ABAD120D    ; 	lda.w i_003
(  62) 026A AB3A        ; 	dec.w a
(  63) 026C AB0A        ; 	asl.w a
(  64) 026E 18          ; 	clc
(  65) 026F CB7501      ; 	adc.w 1,S
(  66) 0272 CB9501      ; 	sta.w 1,S
(  67) 0275 A901        ; 	lda #1
(  68) 0277 8B6B        ; 	pli.s
(  69) 0279 AB8300      ; 	sta.w 0,I++
(  70) 027C ABEE120D    ; 	inc.w i_003
(  71) 0280 4C5402      ; 	jmp L_008
(  72)                  ; L_010
(  73) 0283 ABCE120D    ; 	dec.w i_003
(  74)                  ; ;   16: 
(  75)                  ; ;   17:     prime := 1;
(  76) 0287 A901        ; 	lda #1
(  77) 0289 AB8D180D    ; 	sta.w prime_006
(  78)                  ; ;   18: 
(  79)                  ; ;   19:     REPEAT
(  80)                  ; L_011
(  81)                  ; ;   20:         prime := prime + 1;
(  82) 028D ABAD180D    ; 	lda.w prime_006
(  83) 0291 AB48        ; 	pha.w
(  84) 0293 A901        ; 	lda #1
(  85) 0295 18          ; 	clc
(  86) 0296 CB7501      ; 	adc.w 1,S
(  87) 0299 C202        ; 	adj #2
(  88) 029B AB8D180D    ; 	sta.w prime_006
(  89)                  ; ;   21:         WHILE NOT sieve[prime] DO
(  90)                  ; L_013
(  91) 029F ABE24205    ; 	psh.w #sieve_002
(  92) 02A3 ABAD180D    ; 	lda.w prime_006
(  93) 02A7 AB3A        ; 	dec.w a
(  94) 02A9 AB0A        ; 	asl.w a
(  95) 02AB 18          ; 	clc
(  96) 02AC CB7501      ; 	adc.w 1,S
(  97) 02AF CB9501      ; 	sta.w 1,S
(  98) 02B2 8B6B        ; 	pli.s
(  99) 02B4 ABA300      ; 	lda.w 0,I++
( 100) 02B7 4901        ; 	eor #1
( 101) 02B9 ABC90100    ; 	cmp.w #1
( 102) 02BD F003        ; 	beq L_014
( 103) 02BF 4CD702      ; 	jmp L_015
( 104)                  ; L_014
( 105)                  ; ;   22:             prime := prime + 1;
( 106) 02C2 ABAD180D    ; 	lda.w prime_006
( 107) 02C6 AB48        ; 	pha.w
( 108) 02C8 A901        ; 	lda #1
( 109) 02CA 18          ; 	clc
( 110) 02CB CB7501      ; 	adc.w 1,S
( 111) 02CE C202        ; 	adj #2
( 112) 02D0 AB8D180D    ; 	sta.w prime_006
( 113) 02D4 4C9F02      ; 	jmp L_013
( 114)                  ; L_015
( 115)                  ; ;   23: 
( 116)                  ; ;   24:         factor := 2*prime;
( 117) 02D7 A902        ; 	lda #2
( 118) 02D9 AB48        ; 	pha.w
( 119) 02DB ABAD180D    ; 	lda.w prime_006
( 120) 02DF AB48        ; 	pha.w
( 121) 02E1 206004      ; 	jsr _imul
( 122) 02E4 C204        ; 	adj #4
( 123) 02E6 AB8D1A0D    ; 	sta.w factor_007
( 124)                  ; ;   25: 
( 125)                  ; ;   26:         WHILE factor <= max DO BEGIN
( 126)                  ; L_016
( 127) 02EA ABAD1A0D    ; 	lda.w factor_007
( 128) 02EE AB48        ; 	pha.w
( 129) 02F0 ABA9E803    ; 	lda.w #1000
( 130) 02F4 CB4401      ; 	xma.w 1,S
( 131) 02F7 CBD501      ; 	cmp.w 1,S
( 132) 02FA C202        ; 	adj #2
( 133) 02FC 08          ; 	php
( 134) 02FD A901        ; 	lda #1
( 135) 02FF 28          ; 	plp
( 136) 0300 AB3002      ; 	ble L_019
( 137) 0303 A900        ; 	lda #0
( 138)                  ; L_019
( 139) 0305 ABC90100    ; 	cmp.w #1
( 140) 0309 F003        ; 	beq L_017
( 141) 030B 4C3F03      ; 	jmp L_018
( 142)                  ; L_017
( 143)                  ; ;   27:             sieve[factor] := FALSE;
( 144) 030E ABE24205    ; 	psh.w #sieve_002
( 145) 0312 ABAD1A0D    ; 	lda.w factor_007
( 146) 0316 AB3A        ; 	dec.w a
( 147) 0318 AB0A        ; 	asl.w a
( 148) 031A 18          ; 	clc
( 149) 031B CB7501      ; 	adc.w 1,S
( 150) 031E CB9501      ; 	sta.w 1,S
( 151) 0321 A900        ; 	lda #0
( 152) 0323 8B6B        ; 	pli.s
( 153) 0325 AB8300      ; 	sta.w 0,I++
( 154)                  ; ;   28:             factor := factor + prime;
( 155) 0328 ABAD1A0D    ; 	lda.w factor_007
( 156) 032C AB48        ; 	pha.w
( 157) 032E ABAD180D    ; 	lda.w prime_006
( 158) 0332 18          ; 	clc
( 159) 0333 CB7501      ; 	adc.w 1,S
( 160) 0336 C202        ; 	adj #2
( 161) 0338 AB8D1A0D    ; 	sta.w factor_007
( 162)                  ; ;   29:         END
( 163)                  ; ;   30:     UNTIL prime > limit;
( 164) 033C 4CEA02      ; 	jmp L_016
( 165)                  ; L_018
( 166) 033F ABAD180D    ; 	lda.w prime_006
( 167) 0343 AB48        ; 	pha.w
( 168) 0345 ABAD160D    ; 	lda.w limit_005
( 169) 0349 CB4401      ; 	xma.w 1,S
( 170) 034C CBD501      ; 	cmp.w 1,S
( 171) 034F C202        ; 	adj #2
( 172) 0351 08          ; 	php
( 173) 0352 A901        ; 	lda #1
( 174) 0354 28          ; 	plp
( 175) 0355 AB1002      ; 	bgt L_020
( 176) 0358 A900        ; 	lda #0
( 177)                  ; L_020
( 178) 035A ABC90100    ; 	cmp.w #1
( 179) 035E F003        ; 	beq L_012
( 180) 0360 4C8D02      ; 	jmp L_011
( 181)                  ; L_012
( 182)                  ; ;   31: 
( 183)                  ; ;   32:     writeln('Sieve of Eratosthenes');
( 184) 0363 ABE22C05    ; 	psh.w #S_021
( 185) 0367 ABE20000    ; 	psh.w #0
( 186) 036B ABE21500    ; 	psh.w #21
( 187) 036F 209804      ; 	jsr _swrite
( 188) 0372 C206        ; 	adj #6
( 189) 0374 209204      ; 	jsr _writeln
( 190)                  ; ;   33:     writeln;
( 191) 0377 209204      ; 	jsr _writeln
( 192)                  ; ;   34: 
( 193)                  ; ;   35:     i := 1;
( 194) 037A A901        ; 	lda #1
( 195) 037C AB8D120D    ; 	sta.w i_003
( 196)                  ; ;   36:     REPEAT
( 197)                  ; L_022
( 198)                  ; ;   37:         FOR j := 0 TO 19 DO BEGIN
( 199) 0380 A900        ; 	lda #0
( 200) 0382 AB8D140D    ; 	sta.w j_004
( 201)                  ; L_024
( 202) 0386 A913        ; 	lda #19
( 203) 0388 ABCD140D    ; 	cmp.w j_004
( 204) 038C AB5003      ; 	bge L_025
( 205) 038F 4CF103      ; 	jmp L_026
( 206)                  ; L_025
( 207)                  ; ;   38:             prime := i + j;
( 208) 0392 ABAD120D    ; 	lda.w i_003
( 209) 0396 AB48        ; 	pha.w
( 210) 0398 ABAD140D    ; 	lda.w j_004
( 211) 039C 18          ; 	clc
( 212) 039D CB7501      ; 	adc.w 1,S
( 213) 03A0 C202        ; 	adj #2
( 214) 03A2 AB8D180D    ; 	sta.w prime_006
( 215)                  ; ;   39:             IF sieve[prime] THEN
( 216) 03A6 ABE24205    ; 	psh.w #sieve_002
( 217) 03AA ABAD180D    ; 	lda.w prime_006
( 218) 03AE AB3A        ; 	dec.w a
( 219) 03B0 AB0A        ; 	asl.w a
( 220) 03B2 18          ; 	clc
( 221) 03B3 CB7501      ; 	adc.w 1,S
( 222) 03B6 CB9501      ; 	sta.w 1,S
( 223) 03B9 8B6B        ; 	pli.s
( 224) 03BB ABA300      ; 	lda.w 0,I++
( 225) 03BE ABC90100    ; 	cmp.w #1
( 226) 03C2 F003        ; 	beq L_027
( 227) 03C4 4CD903      ; 	jmp L_028
( 228)                  ; L_027
( 229)                  ; ;   40:                 write(prime:3)
( 230) 03C7 ABAD180D    ; 	lda.w prime_006
( 231) 03CB AB48        ; 	pha.w
( 232) 03CD A903        ; 	lda #3
( 233) 03CF AB48        ; 	pha.w
( 234) 03D1 20AA04      ; 	jsr _iwrite
( 235) 03D4 C204        ; 	adj #4
( 236)                  ; ;   41:             ELSE
( 237) 03D6 4CEA03      ; 	jmp L_029
( 238)                  ; L_028
( 239)                  ; ;   42:                 write('   ');
( 240) 03D9 ABE22905    ; 	psh.w #S_030
( 241) 03DD ABE20000    ; 	psh.w #0
( 242) 03E1 ABE20300    ; 	psh.w #3
( 243) 03E5 209804      ; 	jsr _swrite
( 244) 03E8 C206        ; 	adj #6
( 245)                  ; L_029
( 246)                  ; ;   43:         END;
( 247) 03EA ABEE140D    ; 	inc.w j_004
( 248) 03EE 4C8603      ; 	jmp L_024
( 249)                  ; L_026
( 250) 03F1 ABCE140D    ; 	dec.w j_004
( 251)                  ; ;   44:         writeln;
( 252) 03F5 209204      ; 	jsr _writeln
( 253)                  ; ;   45:         i := i + 20
( 254) 03F8 ABAD120D    ; 	lda.w i_003
( 255) 03FC AB48        ; 	pha.w
( 256) 03FE A914        ; 	lda #20
( 257)                  ; ;   46:     UNTIL i > max
( 258) 0400 18          ; 	clc
( 259) 0401 CB7501      ; 	adc.w 1,S
( 260) 0404 C202        ; 	adj #2
( 261) 0406 AB8D120D    ; 	sta.w i_003
( 262) 040A ABAD120D    ; 	lda.w i_003
( 263) 040E AB48        ; 	pha.w
( 264)                  ; ;   47: END.
( 265) 0410 ABA9E803    ; 	lda.w #1000
( 266) 0414 CB4401      ; 	xma.w 1,S
( 267) 0417 CBD501      ; 	cmp.w 1,S
( 268) 041A C202        ; 	adj #2
( 269) 041C 08          ; 	php
( 270) 041D A901        ; 	lda #1
( 271) 041F 28          ; 	plp
( 272) 0420 AB1002      ; 	bgt L_031
( 273) 0423 A900        ; 	lda #0
( 274)                  ; L_031
( 275) 0425 ABC90100    ; 	cmp.w #1
( 276) 0429 F003        ; 	beq L_023
( 277) 042B 4C8003      ; 	jmp L_022
( 278)                  ; L_023
( 279) 042E ABFA        ; 	plx.w
( 280) 0430 60          ; 	rts
( 281)                  ; 	.end _pc65_main
( 282)                  ; 
( 283)                  ; ;
( 284)                  ; ;   unsigned division 16 x 16
( 285)                  ; ;
( 286)                  ;             .cod
( 287)                  ; ;
( 288)                  ; _Q          .equ    5
( 289)                  ; _D          .equ    3
( 290)                  ; ;
( 291)                  ; _idiv       .proc
( 292) 0431 A900        ;             lda #0          ; clear remainder (A)
( 293) 0433 0B          ;             dup a           ; push
( 294) 0434 CBB505      ;             lda.w _Q,S      ; load dividend (Q)
( 295) 0437 A010        ;             ldy #16         ; bit counter
( 296)                  ; ;
( 297)                  ; _idiv_Lp    
( 298) 0439 18          ;             clc
( 299) 043A AB0A        ;             asl.w a         ; shift AQ left
( 300) 043C 1B          ;             swp a
( 301) 043D AB2A        ;             rol.w a
( 302)                  ; ;
( 303) 043F B006        ;             bcs _idiv_Plus  ; if A < 0 then A = A + D else A = A - D
( 304)                  ; ;
( 305)                  ; _idiv_Minus
( 306) 0441 38          ;             sec
( 307) 0442 CBF503      ;             sbc.w _D,S      ; subtract divisor (D)
( 308)                  ; ;
( 309) 0445 8004        ;             bra _idiv_Next
( 310)                  ; ;
( 311)                  ; _idiv_Plus
( 312) 0447 18          ;             clc
( 313) 0448 CB7503      ;             adc.w _D,S      ; add divisor (D)
( 314)                  ; ;
( 315)                  ; _idiv_Next    
( 316) 044B 1B          ;             swp a           ; restore order of Acc stack {Q, A, -}
( 317) 044C 3002        ;             bmi _idiv_Dec   ; if A < 0 then Q[0] = 0 else Q[0] = 1
( 318) 044E AB1A        ;             inc.w a
( 319)                  ; ;
( 320)                  ; _idiv_Dec
( 321) 0450 88          ;             dey             ; loop until loop counter == 0
( 322) 0451 D0E6        ;             bne _idiv_Lp
( 323)                  ; ;
( 324)                  ; _idiv_Exit
( 325) 0453 1B          ;             swp a           ; Test remainder
( 326) 0454 AB090000    ;             ora.w #0
( 327) 0458 1004        ;             bpl _idiv_Finish
( 328) 045A 18          ;             clc
( 329) 045B CB7503      ;             adc.w 3,S
( 330)                  ; _idiv_Finish
( 331) 045E 1B          ;             swp a
( 332)                  ; ;
( 333) 045F 60          ;             rts
( 334)                  ; ;
( 335)                  ;             .endp _idiv
( 336)                  ; 
( 337)                  ; ;
( 338)                  ; ; signed multiplication: 16 x 16 => 32
( 339)                  ; ;
( 340)                  ;             .cod
( 341)                  ; ;
( 342)                  ; _M          .equ    5
( 343)                  ; _R          .equ    3
( 344)                  ; ;
( 345)                  ; _imul       .proc
( 346) 0460 A010        ;             ldy #16             ; y = bit count
( 347) 0462 A900        ;             lda #0              ; A = { 0,  x,  x} - clear product
( 348) 0464 0B          ;             dup a               ; A = { 0,  0,  x}
( 349) 0465 0B          ;             dup a               ; A = { 0,  0,  0}
( 350) 0466 CBB503      ;             lda.w _R,S          ; A = { R,  0,  0} - load multiplier (R)
( 351) 0469 9B2B        ;             rev                 ; A = {`R,  0,  0} - reverse multiplier (`R)
( 352) 046B AB090000    ;             ora.w #0            ; set N flag if msb ATOS == 1
( 353) 046F 18          ;             clc                 ; initialize Booth recoding bit
( 354) 0470 2B          ;             rot a               ; A = {PH, PL, `R}
( 355)                  ; ;
( 356) 0471 8003        ;             bra _imul_TstB
( 357)                  ; ;
( 358)                  ; _imul_Lp
( 359) 0473 AB0A        ;             asl.w a             ; A = {`R << 1, PH, PL}
( 360) 0475 2B          ;             rot a               ; A = {PH, PL, `R}
( 361)                  ; _imul_TstB
( 362) 0476 9008        ;             bcc _imul_SubShft   ; (C, x) ? Add_Shift : Sub_Shift
( 363)                  ; ;
( 364)                  ; _imul_AddShft
( 365) 0478 300C        ;             bmi _imul_ShftP     ; (1, N) ? P >> 1 : (P += M) >> 1
( 366)                  ; _imul_AddM
( 367) 047A 18          ;             clc
( 368) 047B CB7505      ;             adc.w _M,S          ; PH += M
( 369) 047E 8006        ;             bra _imul_ShftP
( 370)                  ; ;
( 371)                  ; _imul_SubShft
( 372) 0480 1004        ;             bpl _imul_ShftP     ; (0, N) ? (P -= M) >> 1 : P >> 1
( 373)                  ; _imul_SubM
( 374) 0482 38          ;             sec
( 375) 0483 CBF505      ;             sbc.w _M,S          ; PH -= M
( 376)                  ; ;
( 377)                  ; _imul_ShftP
( 378) 0486 BB4A        ;             asr.w a             ; A = {PH >> 1, PL, `R}
( 379) 0488 2B          ;             rot a               ; A = {PL, `R, PH}
( 380) 0489 AB6A        ;             ror.w a             ; A = {PL >> 2, `R, PH}
( 381) 048B 2B          ;             rot a               ; A = {`R, PH, PL}
( 382)                  ; ;
( 383)                  ; _imul_Dec
( 384) 048C 88          ;             dey
( 385) 048D D0E4        ;             bne _imul_Lp
( 386)                  ; ;
( 387)                  ; _imul_Exit
( 388) 048F 2B          ;             rot a               ; A = {PH, PL, `R}
( 389) 0490 1B          ;             swp a               ; A = {PL, PH, `R}
( 390)                  ; ;
( 391) 0491 60          ;             rts
( 392)                  ; ;
( 393)                  ;             .endp _imul
( 394)                  ; 
( 395)                  ; ;
( 396)                  ; ; put <newLine> to output
( 397)                  ; ;
( 398)                  ;             .cod
( 399)                  ; ;
( 400)                  ; _newLine    .equ    0x0A
( 401)                  ; _putChar    .equ    0xF001
( 402)                  ; ;
( 403)                  ; _writeln    .proc
( 404) 0492 A90A        ;             lda #_newLine
( 405) 0494 8D01F0      ;             sta _putChar
( 406)                  ; ;
( 407) 0497 60          ;             rts
( 408)                  ; ;
( 409)                  ;             .endp _writeln
( 410)                  ; ;
( 411)                  ; ; put string to output
( 412)                  ; ;
( 413)                  ;             .cod
( 414)                  ; ;
( 415)                  ; _sPtrOff    .equ    7
( 416)                  ; _sLenOff    .equ    3
( 417)                  ; ;
( 418)                  ; _swrite     .proc
( 419) 0498 CBB403      ;             ldy.w _sLenOff,S        ; load string length
( 420) 049B CBB507      ;             lda.w _sPtrOff,S        ; load string pointer
( 421) 049E 9B0B        ;             tai                     ; transfer sptr to IP
( 422)                  ; ;
( 423)                  ; _swrite_Lp
( 424) 04A0 A300        ;             lda 0,I++               ; load char from strig
( 425) 04A2 8D01F0      ;             sta _putChar            ; write char to output
( 426)                  ; ;
( 427) 04A5 AB88        ;             dey.w                   ; loop while string length <> 0
( 428) 04A7 D0F7        ;             bne _swrite_Lp
( 429)                  ; ;
( 430) 04A9 60          ;             rts
( 431)                  ; ;
( 432)                  ;             .endp _swrite
( 433)                  ; ;
( 434)                  ; ; put integer to output
( 435)                  ; ;
( 436)                  ;             .cod
( 437)                  ; ;
( 438)                  ; _iValOff    .equ    7
( 439)                  ; _fLenOff    .equ    5
( 440)                  ; _iCntOff    .equ    -1
( 441)                  ; ;
( 442)                  ; _iwrite     .proc
( 443) 04AA ABDA        ;             phx.w                   ; save current base pointer
( 444) 04AC ABBA        ;             tsx.w                   ; assign new base pointer
( 445)                  ; ;
( 446) 04AE B505        ;             lda _fLenOff,X          ; load field width specifier
( 447) 04B0 C905        ;             cmp #5                  ; compare against max integer digit count
( 448) 04B2 AB3002      ;             ble _iwrite_SetCnt
( 449) 04B5 A905        ;             lda #5
( 450)                  ; ;
( 451)                  ; _iwrite_SetCnt
( 452) 04B7 AB48        ;             pha.w                   ; set iteration count to fld width
( 453) 04B9 ABB507      ;             lda.w _iValOff,X        ; load a with integer value
( 454)                  ; ;
( 455)                  ; _iwrite_Lp
( 456) 04BC AB48        ;             pha.w                   ; push dividend argument to _idiv
( 457) 04BE ABE20A00    ;             psh.w #10               ; push divisor argument to _idiv
( 458) 04C2 9B5C6BFF    ;             csr _idiv               ; determine the remainder,
( 459) 04C6 C204        ;             adj #4                  ; remove arguments passed to _idiv from stk
( 460) 04C8 1B          ;             swp a                   ; put the remainder into ATOS
( 461)                  ; ;
( 462) 04C9 18          ;             clc                     ; convert remainder into ASCII character
( 463) 04CA 6930        ;             adc #48
( 464) 04CC 48          ;             pha                     ; push LS digit of integer onto stack
( 465)                  ; ;
( 466) 04CD 2B          ;             rot a                   ; rotate quotient into ATOS position
( 467)                  ; ;
( 468) 04CE ABD6FF      ;             dec.w _iCntOff,X        ; decrement digit iteration count
( 469) 04D1 D0E9        ;             bne _iwrite_Lp
( 470)                  ; ;-------------------------------------------------------------------------------
( 471) 04D3 0B          ;             dup a                   ; save integer part of the conversion
( 472)                  ; ;-------------------------------------------------------------------------------
( 473)                  ; _iwrite_Fill
( 474) 04D4 B505        ;             lda _fLenOff,X          ; load field width specifier
( 475) 04D6 C905        ;             cmp #5                  ; compare against max integer digit count
( 476) 04D8 AB300A      ;             ble _iwrite_GenPtr
( 477) 04DB 38          ;             sec                     ; subtract max integer length from fld len
( 478) 04DC E905        ;             sbc #5
( 479) 04DE A8          ;             tay                     ; set difference as loop counter
( 480) 04DF A930        ;             lda #48                 ; fill remaining field with '0'
( 481)                  ; ;
( 482)                  ; _iwrite_Fill_Lp                     ; increase string on stack with fill data
( 483) 04E1 48          ;             pha
( 484) 04E2 88          ;             dey
( 485) 04E3 D0FC        ;             bne _iwrite_Fill_Lp
( 486)                  ; ;-------------------------------------------------------------------------------
( 487)                  ; _iwrite_GenPtr
( 488) 04E5 EBABBA      ;             tsa.w                   ; transfer current stk pointer to A
( 489) 04E8 AB1A        ;             inc.w a                 ; remove stack pointer write bias
( 490) 04EA AB48        ;             pha.w                   ; push string pointer to stack
( 491)                  ; ;-------------------------------------------------------------------------------
( 492) 04EC 2B          ;             rot a                   ; restore integer part of the conversion
( 493)                  ; ;-------------------------------------------------------------------------------
( 494) 04ED ABC90000    ;             cmp.w #0                ; test for 0. If not 0, int > 10^fld
( 495) 04F1 F00F        ;             beq _iwrite_Sup0
( 496) 04F3 A000        ;             ldy #0
( 497)                  ; _iwrite_ErrLp
( 498) 04F5 A92A        ;             lda #0x2A               ; fill integer field with '*'
( 499) 04F7 8B9101      ;             sta (1,S),Y
( 500) 04FA C8          ;             iny
( 501) 04FB FBD505      ;             cmp.y _fLenOff,X
( 502) 04FE D0F5        ;             bne _iwrite_ErrLp
( 503) 0500 8014        ;             bra _iwrite_Exit
( 504)                  ; ;-------------------------------------------------------------------------------
( 505)                  ; _iwrite_Sup0
( 506) 0502 A000        ;             ldy #0                  ; initialize string index
( 507)                  ; _iwrite_Sup0_Lp
( 508) 0504 8BB101      ;             lda (1,S),Y
( 509) 0507 C930        ;             cmp #48                 ; if leading position == 0, replace with ' '
( 510) 0509 D00B        ;             bne _iwrite_Exit        ; exit loop on first non-0 digit
( 511) 050B A920        ;             lda #32                 ; replace leading 0 with ' '
( 512) 050D 8B9101      ;             sta (1,S),Y
( 513) 0510 C8          ;             iny                     ; increment string index and compare to fLen
( 514) 0511 FBD505      ;             cmp.y _fLenOff,X
( 515) 0514 D0EE        ;             bne _iwrite_Sup0_Lp     ; loop until Y == fLen
( 516)                  ; ;-------------------------------------------------------------------------------
( 517)                  ; _iwrite_Exit
( 518) 0516 ABE20000    ;             psh.w #0                ; NULL argument
( 519) 051A B505        ;             lda _fLenOff,X          ; push field width specifier
( 520) 051C AB48        ;             pha.w
( 521) 051E 9B5C76FF    ;             csr _swrite             ; write integer value string using _swrite()
( 522) 0522 C206        ;             adj #6                  ; remove parameters to _swrite() from stack
( 523)                  ; ;
( 524) 0524 AB9A        ;             txs.w                   ; deallocate stack variables
( 525) 0526 ABFA        ;             plx.w                   ; restore previous base pointer
( 526) 0528 60          ;             rts
( 527)                  ; ;
( 528)                  ;             .endp _iwrite
( 529)                  ; 
( 530)                  ; 	.dat
( 531)                  ; 
( 532) 0529 202020      ; S_030 .str "   "
( 533) 052C 53696576    ; S_021 .str "Sieve of Eratosthenes"
       0530 65206F6620457261746F737468656E6573
( 534) 0541 00          ; _bss_start .byt 0
( 535) 0542 00000000    ; sieve_002 .byt 0[2000]
       0546 0000000000000000000000000000000000000000000000000000000000000000
       0566 0000000000000000000000000000000000000000000000000000000000000000
       0586 0000000000000000000000000000000000000000000000000000000000000000
       05A6 0000000000000000000000000000000000000000000000000000000000000000
       05C6 0000000000000000000000000000000000000000000000000000000000000000
       05E6 0000000000000000000000000000000000000000000000000000000000000000
       0606 0000000000000000000000000000000000000000000000000000000000000000
       0626 0000000000000000000000000000000000000000000000000000000000000000
       0646 0000000000000000000000000000000000000000000000000000000000000000
       0666 0000000000000000000000000000000000000000000000000000000000000000
       0686 0000000000000000000000000000000000000000000000000000000000000000
       06A6 0000000000000000000000000000000000000000000000000000000000000000
       06C6 0000000000000000000000000000000000000000000000000000000000000000
       06E6 0000000000000000000000000000000000000000000000000000000000000000
       0706 0000000000000000000000000000000000000000000000000000000000000000
       0726 0000000000000000000000000000000000000000000000000000000000000000
       0746 0000000000000000000000000000000000000000000000000000000000000000
       0766 0000000000000000000000000000000000000000000000000000000000000000
       0786 0000000000000000000000000000000000000000000000000000000000000000
       07A6 0000000000000000000000000000000000000000000000000000000000000000
       07C6 0000000000000000000000000000000000000000000000000000000000000000
       07E6 0000000000000000000000000000000000000000000000000000000000000000
       0806 0000000000000000000000000000000000000000000000000000000000000000
       0826 0000000000000000000000000000000000000000000000000000000000000000
       0846 0000000000000000000000000000000000000000000000000000000000000000
       0866 0000000000000000000000000000000000000000000000000000000000000000
       0886 0000000000000000000000000000000000000000000000000000000000000000
       08A6 0000000000000000000000000000000000000000000000000000000000000000
       08C6 0000000000000000000000000000000000000000000000000000000000000000
       08E6 0000000000000000000000000000000000000000000000000000000000000000
       0906 0000000000000000000000000000000000000000000000000000000000000000
       0926 0000000000000000000000000000000000000000000000000000000000000000
       0946 0000000000000000000000000000000000000000000000000000000000000000
       0966 0000000000000000000000000000000000000000000000000000000000000000
       0986 0000000000000000000000000000000000000000000000000000000000000000
       09A6 0000000000000000000000000000000000000000000000000000000000000000
       09C6 0000000000000000000000000000000000000000000000000000000000000000
       09E6 0000000000000000000000000000000000000000000000000000000000000000
       0A06 0000000000000000000000000000000000000000000000000000000000000000
       0A26 0000000000000000000000000000000000000000000000000000000000000000
       0A46 0000000000000000000000000000000000000000000000000000000000000000
       0A66 0000000000000000000000000000000000000000000000000000000000000000
       0A86 0000000000000000000000000000000000000000000000000000000000000000
       0AA6 0000000000000000000000000000000000000000000000000000000000000000
       0AC6 0000000000000000000000000000000000000000000000000000000000000000
       0AE6 0000000000000000000000000000000000000000000000000000000000000000
       0B06 0000000000000000000000000000000000000000000000000000000000000000
       0B26 0000000000000000000000000000000000000000000000000000000000000000
       0B46 0000000000000000000000000000000000000000000000000000000000000000
       0B66 0000000000000000000000000000000000000000000000000000000000000000
       0B86 0000000000000000000000000000000000000000000000000000000000000000
       0BA6 0000000000000000000000000000000000000000000000000000000000000000
       0BC6 0000000000000000000000000000000000000000000000000000000000000000
       0BE6 0000000000000000000000000000000000000000000000000000000000000000
       0C06 0000000000000000000000000000000000000000000000000000000000000000
       0C26 0000000000000000000000000000000000000000000000000000000000000000
       0C46 0000000000000000000000000000000000000000000000000000000000000000
       0C66 0000000000000000000000000000000000000000000000000000000000000000
       0C86 0000000000000000000000000000000000000000000000000000000000000000
       0CA6 0000000000000000000000000000000000000000000000000000000000000000
       0CC6 0000000000000000000000000000000000000000000000000000000000000000
       0CE6 0000000000000000000000000000000000000000000000000000000000000000
       0D06 000000000000000000000000
( 536) 0D12 0000        ; i_003 .wrd 0
( 537) 0D14 0000        ; j_004 .wrd 0
( 538) 0D16 0000        ; limit_005 .wrd 0
( 539) 0D18 0000        ; prime_006 .wrd 0
( 540) 0D1A 0000        ; factor_007 .wrd 0
( 541) 0D1C 00          ; _bss_end .byt 0
( 542) 0D1D 00000000    ; _stk .byt 0[1023]
       0D21 0000000000000000000000000000000000000000000000000000000000000000
       0D41 0000000000000000000000000000000000000000000000000000000000000000
       0D61 0000000000000000000000000000000000000000000000000000000000000000
       0D81 0000000000000000000000000000000000000000000000000000000000000000
       0DA1 0000000000000000000000000000000000000000000000000000000000000000
       0DC1 0000000000000000000000000000000000000000000000000000000000000000
       0DE1 0000000000000000000000000000000000000000000000000000000000000000
       0E01 0000000000000000000000000000000000000000000000000000000000000000
       0E21 0000000000000000000000000000000000000000000000000000000000000000
       0E41 0000000000000000000000000000000000000000000000000000000000000000
       0E61 0000000000000000000000000000000000000000000000000000000000000000
       0E81 0000000000000000000000000000000000000000000000000000000000000000
       0EA1 0000000000000000000000000000000000000000000000000000000000000000
       0EC1 0000000000000000000000000000000000000000000000000000000000000000
       0EE1 0000000000000000000000000000000000000000000000000000000000000000
       0F01 0000000000000000000000000000000000000000000000000000000000000000
       0F21 0000000000000000000000000000000000000000000000000000000000000000
       0F41 0000000000000000000000000000000000000000000000000000000000000000
       0F61 0000000000000000000000000000000000000000000000000000000000000000
       0F81 0000000000000000000000000000000000000000000000000000000000000000
       0FA1 0000000000000000000000000000000000000000000000000000000000000000
       0FC1 0000000000000000000000000000000000000000000000000000000000000000
       0FE1 0000000000000000000000000000000000000000000000000000000000000000
       1001 0000000000000000000000000000000000000000000000000000000000000000
       1021 0000000000000000000000000000000000000000000000000000000000000000
       1041 0000000000000000000000000000000000000000000000000000000000000000
       1061 0000000000000000000000000000000000000000000000000000000000000000
       1081 0000000000000000000000000000000000000000000000000000000000000000
       10A1 0000000000000000000000000000000000000000000000000000000000000000
       10C1 0000000000000000000000000000000000000000000000000000000000000000
       10E1 0000000000000000000000000000000000000000000000000000000000000000
       1101 000000000000000000000000000000000000000000000000000000
( 543) 111C FF          ; _stk_top .byt -1
( 544)                  ; 
( 545)                  ; 	.end
