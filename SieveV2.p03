(   1)                  ; ;    1: PROGRAM eratosthenes (output);
(   2)                  ; 	.stk 1024
(   3)                  ; 	.cod 512
(   4)                  ; STATIC_LINK .equ +5
(   5)                  ; RETURN_VALUE .equ -3
(   6)                  ; HIGH_RETURN_VALUE .equ -1
(   7)                  ; _start
(   8) 0200 ABBA        ; 	tsx.w		; Preserve original stack pointer
(   9) 0202 CBA24010    ; 	lds.w #_stk_top	; Initialize program stack pointer
(  10)                  ; ;	stz _bss_start
(  11)                  ; ;	ldx.w #_bss_start
(  12)                  ; ;	ldy.w #_bss_start+1
(  13)                  ; ;	lda.w #_stk_top
(  14)                  ; ;	sec
(  15)                  ; ;	sbc.w #_bss_start
(  16)                  ; ;	mov #10
(  17) 0206 4C0902      ; 	jmp _pc65_main
(  18)                  ; ;    2: 
(  19)                  ; ;    3: CONST
(  20)                  ; ;    4:     max = 1000;
(  21)                  ; ;    5: 
(  22)                  ; ;    6: VAR
(  23)                  ; ;    7:     sieve : ARRAY [1..max] OF BOOLEAN;
(  24)                  ; ;    8:     i, j, limit, prime, factor : INTEGER;
(  25)                  ; ;    9: 
(  26)                  ; ;   10: BEGIN
(  27)                  ; _pc65_main .sub
(  28) 0209 ABDA        ; 	phx.w
(  29) 020B ABBA        ; 	tsx.w
(  30)                  ; ;   11:     limit := max DIV 2;
(  31)                  ; 	lda.w #1000
(  32) 020D ABE2E803    ; 	psh.w #1000
(  33)                  ; 	lda #2
(  34) 0211 ABE20200    ; 	psh.w #2
(  35) 0215 205503      ; 	jsr _idiv
(  36) 0218 C204        ; 	adj #4
(  37) 021A AB8D3A0C    ; 	sta.w limit_005
(  38)                  ; ;   12:     sieve[1] := FALSE;
(  39)                  ; 	psh.w #sieve_002
(  40) 021E A901        ; 	lda #1
(  41) 0220 AB3A        ; 	dec.w a
(  42) 0222 AB0A        ; 	asl.w a
(  43) 0224 ABA8        ; 	tay.w 
(  44)                  ; 	adc.w 1,S
(  45)                  ; 	sta.w 1,S
(  46) 0226 A900        ; 	lda #0
(  47)                  ; 	pli.s
(  48) 0228 AB996604    ; 	sta.w sieve_002,Y
(  49)                  ; ;   13: 
(  50)                  ; ;   14:     {FOR i := 2 TO max DO
(  51)                  ; ;   15:         sieve[i] := TRUE;}
(  52)                  ; ;   16: 
(  53)                  ; ;   17:     prime := 1;
(  54) 022C A901        ; 	lda #1
(  55) 022E AB8D3C0C    ; 	sta.w prime_006
(  56)                  ; ;   18: 
(  57)                  ; ;   19:     REPEAT
(  58)                  ; L_008
(  59)                  ; ;   20:         prime := prime + 1;
(  60)                  ; 	lda.w prime_006
(  61)                  ; 	pha.w
(  62)                  ; 	lda #1
(  63)                  ; 	clc
(  64)                  ; 	adc.w 1,S
(  65)                  ; 	adj #2
(  66) 0232 ABEE3C0C    ; 	inc.w prime_006
(  67)                  ; ;   21:         WHILE NOT sieve[prime] DO
(  68)                  ; L_010
(  69)                  ; 	psh.w #sieve_002
(  70) 0236 ABAD3C0C    ; 	lda.w prime_006
(  71) 023A AB3A        ; 	dec.w a
(  72) 023C AB0A        ; 	asl.w a
(  73) 023E ABA8        ; 	tay.w 
(  74)                  ; 	adc.w 1,S
(  75)                  ; 	sta.w 1,S
(  76)                  ; 	pli.s
(  77) 0240 ABB96604    ; 	lda.w sieve_002,Y
(  78) 0244 4901        ; 	eor #1
(  79)                  ; 	cmp.w #1
(  80) 0246 D003        ; 	bne L_011
(  81) 0248 4C5202      ; 	jmp L_012
(  82)                  ; L_011
(  83)                  ; ;   22:             prime := prime + 1;
(  84)                  ; 	lda.w prime_006
(  85)                  ; 	pha.w
(  86)                  ; 	lda #1
(  87)                  ; 	clc
(  88)                  ; 	adc.w 1,S
(  89)                  ; 	adj #2
(  90) 024B ABEE3C0C    ; 	inc.w prime_006
(  91) 024F 4C3602      ; 	jmp L_010
(  92)                  ; L_012
(  93)                  ; ;   23: 
(  94)                  ; ;   24:         factor := prime*2;
(  95) 0252 ABAD3C0C    ; 	lda.w prime_006
(  96) 0256 AB48        ; 	pha.w
(  97)                  ; 	lda #2
(  98) 0258 ABE20200    ; 	psh.w #2
(  99) 025C 208403      ; 	jsr _imul
( 100) 025F C204        ; 	adj #4
( 101) 0261 AB8D3E0C    ; 	sta.w factor_007
( 102)                  ; ;   25: 
( 103)                  ; ;   26:         WHILE factor <= max DO BEGIN
( 104)                  ; L_013
( 105) 0265 ABAD3E0C    ; 	lda.w factor_007
( 106)                  ; 	pha.w
( 107)                  ; 	lda.w #1000
( 108)                  ; 	xma.w 1,S
( 109) 0269 ABC9E803    ; 	cmp.w #1000
( 110)                  ; 	adj #2
( 111) 026D AB3004      ; 	ble L_016T
( 112) 0270 A900        ; 	lda #0
( 113) 0272 8002        ; 	bra L_016
( 114) 0274 A901        ; L_016T lda #1
( 115)                  ; 	lda #0
( 116)                  ; L_016
( 117)                  ; 	cmp.w #1
( 118) 0276 D003        ; 	bne L_014
( 119) 0278 4C9B02      ; 	jmp L_015
( 120)                  ; L_014
( 121)                  ; ;   27:             sieve[factor] := FALSE;
( 122)                  ; 	psh.w #sieve_002
( 123) 027B ABAD3E0C    ; 	lda.w factor_007
( 124) 027F AB3A        ; 	dec.w a
( 125) 0281 AB0A        ; 	asl.w a
( 126) 0283 ABA8        ; 	tay.w 
( 127)                  ; 	adc.w 1,S
( 128)                  ; 	sta.w 1,S
( 129) 0285 A900        ; 	lda #0
( 130)                  ; 	pli.s
( 131) 0287 AB996604    ; 	sta.w sieve_002,Y
( 132)                  ; ;   28:             factor := factor + prime;
( 133) 028B ABAD3E0C    ; 	lda.w factor_007
( 134)                  ; 	pha.w
( 135)                  ; 	lda.w prime_006
( 136) 028F 18          ; 	clc
( 137) 0290 AB6D3C0C    ; 	adc.w prime_006
( 138)                  ; 	adj #2
( 139) 0294 AB8D3E0C    ; 	sta.w factor_007
( 140)                  ; ;   29:         END
( 141)                  ; ;   30:     UNTIL prime > limit;
( 142) 0298 4C6502      ; 	jmp L_013
( 143)                  ; L_015
( 144) 029B ABAD3C0C    ; 	lda.w prime_006
( 145)                  ; 	pha.w
( 146)                  ; 	lda.w limit_005
( 147)                  ; 	xma.w 1,S
( 148) 029F ABCD3A0C    ; 	cmp.w limit_005
( 149)                  ; 	adj #2
( 150) 02A3 AB1004      ; 	bgt L_017T
( 151) 02A6 A900        ; 	lda #0
( 152) 02A8 8002        ; 	bra L_017
( 153) 02AA A901        ; L_017T lda #1
( 154)                  ; 	lda #0
( 155)                  ; L_017
( 156)                  ; 	cmp.w #1
( 157) 02AC D003        ; 	bne L_009
( 158) 02AE 4C3202      ; 	jmp L_008
( 159)                  ; L_009
( 160)                  ; ;   31: 
( 161)                  ; ;   32:     writeln('Sieve of Eratosthenes');
( 162) 02B1 ABE25004    ; 	psh.w #S_018
( 163) 02B5 ABE20000    ; 	psh.w #0
( 164) 02B9 ABE21500    ; 	psh.w #21
( 165) 02BD 20BC03      ; 	jsr _swrite
( 166) 02C0 C206        ; 	adj #6
( 167) 02C2 20B603      ; 	jsr _writeln
( 168)                  ; ;   33:     writeln;
( 169) 02C5 20B603      ; 	jsr _writeln
( 170)                  ; ;   34: 
( 171)                  ; ;   35:     i := 1;
( 172) 02C8 A901        ; 	lda #1
( 173) 02CA AB8D360C    ; 	sta.w i_003
( 174)                  ; ;   36:     REPEAT
( 175)                  ; L_019
( 176)                  ; ;   37:         FOR j := 0 TO 19 DO BEGIN
( 177)                  ; 	lda #0
( 178) 02CE AB9C380C    ; 	stz.w j_004
( 179)                  ; L_021
( 180) 02D2 A913        ; 	lda #19
( 181) 02D4 ABCD380C    ; 	cmp.w j_004
( 182) 02D8 AB5003      ; 	bge L_022
( 183) 02DB 4C2803      ; 	jmp L_023
( 184)                  ; L_022
( 185)                  ; ;   38:             prime := i + j;
( 186) 02DE ABAD360C    ; 	lda.w i_003
( 187)                  ; 	pha.w
( 188)                  ; 	lda.w j_004
( 189) 02E2 18          ; 	clc
( 190) 02E3 AB6D380C    ; 	adc.w j_004
( 191)                  ; 	adj #2
( 192) 02E7 AB8D3C0C    ; 	sta.w prime_006
( 193)                  ; ;   39:             IF sieve[prime] THEN
( 194)                  ; 	psh.w #sieve_002
( 195) 02EB ABAD3C0C    ; 	lda.w prime_006
( 196) 02EF AB3A        ; 	dec.w a
( 197) 02F1 AB0A        ; 	asl.w a
( 198) 02F3 ABA8        ; 	tay.w 
( 199)                  ; 	adc.w 1,S
( 200)                  ; 	sta.w 1,S
( 201)                  ; 	pli.s
( 202) 02F5 ABB96604    ; 	lda.w sieve_002,Y
( 203)                  ; 	cmp.w #1
( 204) 02F9 D003        ; 	bne L_024
( 205) 02FB 4C1003      ; 	jmp L_025
( 206)                  ; L_024
( 207)                  ; ;   40:                 write(prime:3)
( 208) 02FE ABAD3C0C    ; 	lda.w prime_006
( 209) 0302 AB48        ; 	pha.w
( 210)                  ; 	lda #3
( 211) 0304 ABE20300    ; 	psh.w #3
( 212) 0308 20CE03      ; 	jsr _iwrite
( 213) 030B C204        ; 	adj #4
( 214)                  ; ;   41:             ELSE
( 215) 030D 4C2103      ; 	jmp L_026
( 216)                  ; L_025
( 217)                  ; ;   42:                 write('   ');
( 218) 0310 ABE24D04    ; 	psh.w #S_027
( 219) 0314 ABE20000    ; 	psh.w #0
( 220) 0318 ABE20300    ; 	psh.w #3
( 221) 031C 20BC03      ; 	jsr _swrite
( 222) 031F C206        ; 	adj #6
( 223)                  ; L_026
( 224)                  ; ;   43:         END;
( 225) 0321 ABEE380C    ; 	inc.w j_004
( 226) 0325 4CD202      ; 	jmp L_021
( 227)                  ; L_023
( 228) 0328 ABCE380C    ; 	dec.w j_004
( 229)                  ; ;   44:         writeln;
( 230) 032C 20B603      ; 	jsr _writeln
( 231)                  ; ;   45:         i := i + 20
( 232) 032F ABAD360C    ; 	lda.w i_003
( 233)                  ; 	pha.w
( 234)                  ; 	lda #20
( 235)                  ; ;   46:     UNTIL i > max
( 236) 0333 18          ; 	clc
( 237) 0334 AB691400    ; 	adc.w #20
( 238)                  ; 	adj #2
( 239) 0338 AB8D360C    ; 	sta.w i_003
( 240) 033C ABAD360C    ; 	lda.w i_003
( 241)                  ; 	pha.w
( 242)                  ; ;   47: END.
( 243)                  ; 	lda.w #1000
( 244)                  ; 	xma.w 1,S
( 245) 0340 ABC9E803    ; 	cmp.w #1000
( 246)                  ; 	adj #2
( 247) 0344 AB1004      ; 	bgt L_028T
( 248) 0347 A900        ; 	lda #0
( 249) 0349 8002        ; 	bra L_028
( 250) 034B A901        ; L_028T lda #1
( 251)                  ; 	lda #0
( 252)                  ; L_028
( 253)                  ; 	cmp.w #1
( 254) 034D D003        ; 	bne L_020
( 255) 034F 4CCE02      ; 	jmp L_019
( 256)                  ; L_020
( 257) 0352 ABFA        ; 	plx.w
( 258) 0354 60          ; 	rts
( 259)                  ; 	.end _pc65_main
( 260)                  ; 
( 261)                  ; ;
( 262)                  ; ;   unsigned division 16 x 16
( 263)                  ; ;
( 264)                  ;             .cod
( 265)                  ; ;
( 266)                  ; _Q          .equ    5
( 267)                  ; _D          .equ    3
( 268)                  ; ;
( 269)                  ; _idiv       .proc
( 270) 0355 A900        ;             lda #0          ; clear remainder (A)
( 271) 0357 0B          ;             dup a           ; push
( 272) 0358 CBB505      ;             lda.w _Q,S      ; load dividend (Q)
( 273) 035B A010        ;             ldy #16         ; bit counter
( 274)                  ; ;
( 275)                  ; _idiv_Lp    
( 276) 035D 18          ;             clc
( 277) 035E AB0A        ;             asl.w a         ; shift AQ left
( 278) 0360 1B          ;             swp a
( 279) 0361 AB2A        ;             rol.w a
( 280)                  ; ;
( 281) 0363 B006        ;             bcs _idiv_Plus  ; if A < 0 then A = A + D else A = A - D
( 282)                  ; ;
( 283)                  ; _idiv_Minus
( 284) 0365 38          ;             sec
( 285) 0366 CBF503      ;             sbc.w _D,S      ; subtract divisor (D)
( 286)                  ; ;
( 287) 0369 8004        ;             bra _idiv_Next
( 288)                  ; ;
( 289)                  ; _idiv_Plus
( 290) 036B 18          ;             clc
( 291) 036C CB7503      ;             adc.w _D,S      ; add divisor (D)
( 292)                  ; ;
( 293)                  ; _idiv_Next    
( 294) 036F 1B          ;             swp a           ; restore order of Acc stack {Q, A, -}
( 295) 0370 3002        ;             bmi _idiv_Dec   ; if A < 0 then Q[0] = 0 else Q[0] = 1
( 296) 0372 AB1A        ;             inc.w a
( 297)                  ; ;
( 298)                  ; _idiv_Dec
( 299) 0374 88          ;             dey             ; loop until loop counter == 0
( 300) 0375 D0E6        ;             bne _idiv_Lp
( 301)                  ; ;
( 302)                  ; _idiv_Exit
( 303) 0377 1B          ;             swp a           ; Test remainder
( 304) 0378 AB090000    ;             ora.w #0
( 305) 037C 1004        ;             bpl _idiv_Finish
( 306) 037E 18          ;             clc
( 307) 037F CB7503      ;             adc.w 3,S
( 308)                  ; _idiv_Finish
( 309) 0382 1B          ;             swp a
( 310)                  ; ;
( 311) 0383 60          ;             rts
( 312)                  ; ;
( 313)                  ;             .endp _idiv
( 314)                  ; 
( 315)                  ; ;
( 316)                  ; ; signed multiplication: 16 x 16 => 32
( 317)                  ; ;
( 318)                  ;             .cod
( 319)                  ; ;
( 320)                  ; _M          .equ    5
( 321)                  ; _R          .equ    3
( 322)                  ; ;
( 323)                  ; _imul       .proc
( 324) 0384 A010        ;             ldy #16             ; y = bit count
( 325) 0386 A900        ;             lda #0              ; A = { 0,  x,  x} - clear product
( 326) 0388 0B          ;             dup a               ; A = { 0,  0,  x}
( 327) 0389 0B          ;             dup a               ; A = { 0,  0,  0}
( 328) 038A CBB503      ;             lda.w _R,S          ; A = { R,  0,  0} - load multiplier (R)
( 329) 038D 9B2B        ;             rev                 ; A = {`R,  0,  0} - reverse multiplier (`R)
( 330) 038F AB090000    ;             ora.w #0            ; set N flag if msb ATOS == 1
( 331) 0393 18          ;             clc                 ; initialize Booth recoding bit
( 332) 0394 2B          ;             rot a               ; A = {PH, PL, `R}
( 333)                  ; ;
( 334) 0395 8003        ;             bra _imul_TstB
( 335)                  ; ;
( 336)                  ; _imul_Lp
( 337) 0397 AB0A        ;             asl.w a             ; A = {`R << 1, PH, PL}
( 338) 0399 2B          ;             rot a               ; A = {PH, PL, `R}
( 339)                  ; _imul_TstB
( 340) 039A 9008        ;             bcc _imul_SubShft   ; (C, x) ? Add_Shift : Sub_Shift
( 341)                  ; ;
( 342)                  ; _imul_AddShft
( 343) 039C 300C        ;             bmi _imul_ShftP     ; (1, N) ? P >> 1 : (P += M) >> 1
( 344)                  ; _imul_AddM
( 345) 039E 18          ;             clc
( 346) 039F CB7505      ;             adc.w _M,S          ; PH += M
( 347) 03A2 8006        ;             bra _imul_ShftP
( 348)                  ; ;
( 349)                  ; _imul_SubShft
( 350) 03A4 1004        ;             bpl _imul_ShftP     ; (0, N) ? (P -= M) >> 1 : P >> 1
( 351)                  ; _imul_SubM
( 352) 03A6 38          ;             sec
( 353) 03A7 CBF505      ;             sbc.w _M,S          ; PH -= M
( 354)                  ; ;
( 355)                  ; _imul_ShftP
( 356) 03AA BB4A        ;             asr.w a             ; A = {PH >> 1, PL, `R}
( 357) 03AC 2B          ;             rot a               ; A = {PL, `R, PH}
( 358) 03AD AB6A        ;             ror.w a             ; A = {PL >> 2, `R, PH}
( 359) 03AF 2B          ;             rot a               ; A = {`R, PH, PL}
( 360)                  ; ;
( 361)                  ; _imul_Dec
( 362) 03B0 88          ;             dey
( 363) 03B1 D0E4        ;             bne _imul_Lp
( 364)                  ; ;
( 365)                  ; _imul_Exit
( 366) 03B3 2B          ;             rot a               ; A = {PH, PL, `R}
( 367) 03B4 1B          ;             swp a               ; A = {PL, PH, `R}
( 368)                  ; ;
( 369) 03B5 60          ;             rts
( 370)                  ; ;
( 371)                  ;             .endp _imul
( 372)                  ; 
( 373)                  ; ;
( 374)                  ; ; put <newLine> to output
( 375)                  ; ;
( 376)                  ;             .cod
( 377)                  ; ;
( 378)                  ; _newLine    .equ    0x0A
( 379)                  ; _putChar    .equ    0xF001
( 380)                  ; ;
( 381)                  ; _writeln    .proc
( 382) 03B6 A90A        ;             lda #_newLine
( 383) 03B8 8D01F0      ;             sta _putChar
( 384)                  ; ;
( 385) 03BB 60          ;             rts
( 386)                  ; ;
( 387)                  ;             .endp _writeln
( 388)                  ; ;
( 389)                  ; ; put string to output
( 390)                  ; ;
( 391)                  ;             .cod
( 392)                  ; ;
( 393)                  ; _sPtrOff    .equ    7
( 394)                  ; _sLenOff    .equ    3
( 395)                  ; ;
( 396)                  ; _swrite     .proc
( 397) 03BC CBB403      ;             ldy.w _sLenOff,S        ; load string length
( 398) 03BF CBB507      ;             lda.w _sPtrOff,S        ; load string pointer
( 399) 03C2 9B0B        ;             tai                     ; transfer sptr to IP
( 400)                  ; ;
( 401)                  ; _swrite_Lp
( 402) 03C4 A300        ;             lda 0,I++               ; load char from strig
( 403) 03C6 8D01F0      ;             sta _putChar            ; write char to output
( 404)                  ; ;
( 405) 03C9 AB88        ;             dey.w                   ; loop while string length <> 0
( 406) 03CB D0F7        ;             bne _swrite_Lp
( 407)                  ; ;
( 408) 03CD 60          ;             rts
( 409)                  ; ;
( 410)                  ;             .endp _swrite
( 411)                  ; ;
( 412)                  ; ; put integer to output
( 413)                  ; ;
( 414)                  ;             .cod
( 415)                  ; ;
( 416)                  ; _iValOff    .equ    7
( 417)                  ; _fLenOff    .equ    5
( 418)                  ; _iCntOff    .equ    -1
( 419)                  ; ;
( 420)                  ; _iwrite     .proc
( 421) 03CE ABDA        ;             phx.w                   ; save current base pointer
( 422) 03D0 ABBA        ;             tsx.w                   ; assign new base pointer
( 423)                  ; ;
( 424) 03D2 B505        ;             lda _fLenOff,X          ; load field width specifier
( 425) 03D4 C905        ;             cmp #5                  ; compare against max integer digit count
( 426) 03D6 AB3002      ;             ble _iwrite_SetCnt
( 427) 03D9 A905        ;             lda #5
( 428)                  ; ;
( 429)                  ; _iwrite_SetCnt
( 430) 03DB AB48        ;             pha.w                   ; set iteration count to fld width
( 431) 03DD ABB507      ;             lda.w _iValOff,X        ; load a with integer value
( 432)                  ; ;
( 433)                  ; _iwrite_Lp
( 434) 03E0 AB48        ;             pha.w                   ; push dividend argument to _idiv
( 435) 03E2 ABE20A00    ;             psh.w #10               ; push divisor argument to _idiv
( 436) 03E6 9B5C6BFF    ;             csr _idiv               ; determine the remainder,
( 437) 03EA C204        ;             adj #4                  ; remove arguments passed to _idiv from stk
( 438) 03EC 1B          ;             swp a                   ; put the remainder into ATOS
( 439)                  ; ;
( 440) 03ED 18          ;             clc                     ; convert remainder into ASCII character
( 441) 03EE 6930        ;             adc #48
( 442) 03F0 48          ;             pha                     ; push LS digit of integer onto stack
( 443)                  ; ;
( 444) 03F1 2B          ;             rot a                   ; rotate quotient into ATOS position
( 445)                  ; ;
( 446) 03F2 ABD6FF      ;             dec.w _iCntOff,X        ; decrement digit iteration count
( 447) 03F5 D0E9        ;             bne _iwrite_Lp
( 448)                  ; ;-------------------------------------------------------------------------------
( 449) 03F7 0B          ;             dup a                   ; save integer part of the conversion
( 450)                  ; ;-------------------------------------------------------------------------------
( 451)                  ; _iwrite_Fill
( 452) 03F8 B505        ;             lda _fLenOff,X          ; load field width specifier
( 453) 03FA C905        ;             cmp #5                  ; compare against max integer digit count
( 454) 03FC AB300A      ;             ble _iwrite_GenPtr
( 455) 03FF 38          ;             sec                     ; subtract max integer length from fld len
( 456) 0400 E905        ;             sbc #5
( 457) 0402 A8          ;             tay                     ; set difference as loop counter
( 458) 0403 A930        ;             lda #48                 ; fill remaining field with '0'
( 459)                  ; ;
( 460)                  ; _iwrite_Fill_Lp                     ; increase string on stack with fill data
( 461) 0405 48          ;             pha
( 462) 0406 88          ;             dey
( 463) 0407 D0FC        ;             bne _iwrite_Fill_Lp
( 464)                  ; ;-------------------------------------------------------------------------------
( 465)                  ; _iwrite_GenPtr
( 466) 0409 EBABBA      ;             tsa.w                   ; transfer current stk pointer to A
( 467) 040C AB1A        ;             inc.w a                 ; remove stack pointer write bias
( 468) 040E AB48        ;             pha.w                   ; push string pointer to stack
( 469)                  ; ;-------------------------------------------------------------------------------
( 470) 0410 2B          ;             rot a                   ; restore integer part of the conversion
( 471)                  ; ;-------------------------------------------------------------------------------
( 472) 0411 ABC90000    ;             cmp.w #0                ; test for 0. If not 0, int > 10^fld
( 473) 0415 F00F        ;             beq _iwrite_Sup0
( 474) 0417 A000        ;             ldy #0
( 475)                  ; _iwrite_ErrLp
( 476) 0419 A92A        ;             lda #0x2A               ; fill integer field with '*'
( 477) 041B 8B9101      ;             sta (1,S),Y
( 478) 041E C8          ;             iny
( 479) 041F FBD505      ;             cmp.y _fLenOff,X
( 480) 0422 D0F5        ;             bne _iwrite_ErrLp
( 481) 0424 8014        ;             bra _iwrite_Exit
( 482)                  ; ;-------------------------------------------------------------------------------
( 483)                  ; _iwrite_Sup0
( 484) 0426 A000        ;             ldy #0                  ; initialize string index
( 485)                  ; _iwrite_Sup0_Lp
( 486) 0428 8BB101      ;             lda (1,S),Y
( 487) 042B C930        ;             cmp #48                 ; if leading position == 0, replace with ' '
( 488) 042D D00B        ;             bne _iwrite_Exit        ; exit loop on first non-0 digit
( 489) 042F A920        ;             lda #32                 ; replace leading 0 with ' '
( 490) 0431 8B9101      ;             sta (1,S),Y
( 491) 0434 C8          ;             iny                     ; increment string index and compare to fLen
( 492) 0435 FBD505      ;             cmp.y _fLenOff,X
( 493) 0438 D0EE        ;             bne _iwrite_Sup0_Lp     ; loop until Y == fLen
( 494)                  ; ;-------------------------------------------------------------------------------
( 495)                  ; _iwrite_Exit
( 496) 043A ABE20000    ;             psh.w #0                ; NULL argument
( 497) 043E B505        ;             lda _fLenOff,X          ; push field width specifier
( 498) 0440 AB48        ;             pha.w
( 499) 0442 9B5C76FF    ;             csr _swrite             ; write integer value string using _swrite()
( 500) 0446 C206        ;             adj #6                  ; remove parameters to _swrite() from stack
( 501)                  ; ;
( 502) 0448 AB9A        ;             txs.w                   ; deallocate stack variables
( 503) 044A ABFA        ;             plx.w                   ; restore previous base pointer
( 504) 044C 60          ;             rts
( 505)                  ; ;
( 506)                  ;             .endp _iwrite
( 507)                  ; 
( 508)                  ; 	.dat
( 509)                  ; 
( 510) 044D 202020      ; S_027 .str "   "
( 511) 0450 53696576    ; S_018 .str "Sieve of Eratosthenes"
       0454 65206F6620457261746F737468656E6573
( 512) 0465 00          ; _bss_start .byt 0
( 513) 0466 01000100    ; sieve_002 .wrd 1[1000]
       046A 0100010001000100010001000100010001000100010001000100010001000100
       048A 0100010001000100010001000100010001000100010001000100010001000100
       04AA 0100010001000100010001000100010001000100010001000100010001000100
       04CA 0100010001000100010001000100010001000100010001000100010001000100
       04EA 0100010001000100010001000100010001000100010001000100010001000100
       050A 0100010001000100010001000100010001000100010001000100010001000100
       052A 0100010001000100010001000100010001000100010001000100010001000100
       054A 0100010001000100010001000100010001000100010001000100010001000100
       056A 0100010001000100010001000100010001000100010001000100010001000100
       058A 0100010001000100010001000100010001000100010001000100010001000100
       05AA 0100010001000100010001000100010001000100010001000100010001000100
       05CA 0100010001000100010001000100010001000100010001000100010001000100
       05EA 0100010001000100010001000100010001000100010001000100010001000100
       060A 0100010001000100010001000100010001000100010001000100010001000100
       062A 0100010001000100010001000100010001000100010001000100010001000100
       064A 0100010001000100010001000100010001000100010001000100010001000100
       066A 0100010001000100010001000100010001000100010001000100010001000100
       068A 0100010001000100010001000100010001000100010001000100010001000100
       06AA 0100010001000100010001000100010001000100010001000100010001000100
       06CA 0100010001000100010001000100010001000100010001000100010001000100
       06EA 0100010001000100010001000100010001000100010001000100010001000100
       070A 0100010001000100010001000100010001000100010001000100010001000100
       072A 0100010001000100010001000100010001000100010001000100010001000100
       074A 0100010001000100010001000100010001000100010001000100010001000100
       076A 0100010001000100010001000100010001000100010001000100010001000100
       078A 0100010001000100010001000100010001000100010001000100010001000100
       07AA 0100010001000100010001000100010001000100010001000100010001000100
       07CA 0100010001000100010001000100010001000100010001000100010001000100
       07EA 0100010001000100010001000100010001000100010001000100010001000100
       080A 0100010001000100010001000100010001000100010001000100010001000100
       082A 0100010001000100010001000100010001000100010001000100010001000100
       084A 0100010001000100010001000100010001000100010001000100010001000100
       086A 0100010001000100010001000100010001000100010001000100010001000100
       088A 0100010001000100010001000100010001000100010001000100010001000100
       08AA 0100010001000100010001000100010001000100010001000100010001000100
       08CA 0100010001000100010001000100010001000100010001000100010001000100
       08EA 0100010001000100010001000100010001000100010001000100010001000100
       090A 0100010001000100010001000100010001000100010001000100010001000100
       092A 0100010001000100010001000100010001000100010001000100010001000100
       094A 0100010001000100010001000100010001000100010001000100010001000100
       096A 0100010001000100010001000100010001000100010001000100010001000100
       098A 0100010001000100010001000100010001000100010001000100010001000100
       09AA 0100010001000100010001000100010001000100010001000100010001000100
       09CA 0100010001000100010001000100010001000100010001000100010001000100
       09EA 0100010001000100010001000100010001000100010001000100010001000100
       0A0A 0100010001000100010001000100010001000100010001000100010001000100
       0A2A 0100010001000100010001000100010001000100010001000100010001000100
       0A4A 0100010001000100010001000100010001000100010001000100010001000100
       0A6A 0100010001000100010001000100010001000100010001000100010001000100
       0A8A 0100010001000100010001000100010001000100010001000100010001000100
       0AAA 0100010001000100010001000100010001000100010001000100010001000100
       0ACA 0100010001000100010001000100010001000100010001000100010001000100
       0AEA 0100010001000100010001000100010001000100010001000100010001000100
       0B0A 0100010001000100010001000100010001000100010001000100010001000100
       0B2A 0100010001000100010001000100010001000100010001000100010001000100
       0B4A 0100010001000100010001000100010001000100010001000100010001000100
       0B6A 0100010001000100010001000100010001000100010001000100010001000100
       0B8A 0100010001000100010001000100010001000100010001000100010001000100
       0BAA 0100010001000100010001000100010001000100010001000100010001000100
       0BCA 0100010001000100010001000100010001000100010001000100010001000100
       0BEA 0100010001000100010001000100010001000100010001000100010001000100
       0C0A 0100010001000100010001000100010001000100010001000100010001000100
       0C2A 010001000100010001000100
( 514) 0C36 0000        ; i_003 .wrd 0
( 515) 0C38 0000        ; j_004 .wrd 0
( 516) 0C3A 0000        ; limit_005 .wrd 0
( 517) 0C3C 0000        ; prime_006 .wrd 0
( 518) 0C3E 0000        ; factor_007 .wrd 0
( 519) 0C40 00          ; _bss_end .byt 0
( 520) 0C41 00000000    ; _stk .byt 0[1023]
       0C45 0000000000000000000000000000000000000000000000000000000000000000
       0C65 0000000000000000000000000000000000000000000000000000000000000000
       0C85 0000000000000000000000000000000000000000000000000000000000000000
       0CA5 0000000000000000000000000000000000000000000000000000000000000000
       0CC5 0000000000000000000000000000000000000000000000000000000000000000
       0CE5 0000000000000000000000000000000000000000000000000000000000000000
       0D05 0000000000000000000000000000000000000000000000000000000000000000
       0D25 0000000000000000000000000000000000000000000000000000000000000000
       0D45 0000000000000000000000000000000000000000000000000000000000000000
       0D65 0000000000000000000000000000000000000000000000000000000000000000
       0D85 0000000000000000000000000000000000000000000000000000000000000000
       0DA5 0000000000000000000000000000000000000000000000000000000000000000
       0DC5 0000000000000000000000000000000000000000000000000000000000000000
       0DE5 0000000000000000000000000000000000000000000000000000000000000000
       0E05 0000000000000000000000000000000000000000000000000000000000000000
       0E25 0000000000000000000000000000000000000000000000000000000000000000
       0E45 0000000000000000000000000000000000000000000000000000000000000000
       0E65 0000000000000000000000000000000000000000000000000000000000000000
       0E85 0000000000000000000000000000000000000000000000000000000000000000
       0EA5 0000000000000000000000000000000000000000000000000000000000000000
       0EC5 0000000000000000000000000000000000000000000000000000000000000000
       0EE5 0000000000000000000000000000000000000000000000000000000000000000
       0F05 0000000000000000000000000000000000000000000000000000000000000000
       0F25 0000000000000000000000000000000000000000000000000000000000000000
       0F45 0000000000000000000000000000000000000000000000000000000000000000
       0F65 0000000000000000000000000000000000000000000000000000000000000000
       0F85 0000000000000000000000000000000000000000000000000000000000000000
       0FA5 0000000000000000000000000000000000000000000000000000000000000000
       0FC5 0000000000000000000000000000000000000000000000000000000000000000
       0FE5 0000000000000000000000000000000000000000000000000000000000000000
       1005 0000000000000000000000000000000000000000000000000000000000000000
       1025 000000000000000000000000000000000000000000000000000000
( 521) 1040 FF          ; _stk_top .byt -1
( 522)                  ; 
( 523)                  ; 	.end
